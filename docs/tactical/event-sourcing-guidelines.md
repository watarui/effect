# Event Sourcing ガイドライン

## 概要

Event Sourcing は、アプリケーションの状態変更をすべてイベントのシーケンスとして保存するパターンです。Effect プロジェクトでは、CQRS と組み合わせて高い監査性と柔軟性を実現しています。

## 設計原則

### 1. イベントは不変

- 一度保存されたイベントは変更・削除不可
- 誤りの修正は補償イベントで対応
- 完全な監査証跡を維持

### 2. イベントは事実の記録

- 「何が起きたか」を記録（過去形で命名）
- ビジネス上の意味を持つ
- 技術的な詳細は含まない

### 3. イベントの順序性

- ストリーム内でのイベント順序を保証
- グローバルな順序は保証しない
- 因果関係の維持

## イベント設計

### イベントの命名規則

```
[集約名][動詞の過去形]
```

例：

- `VocabularyItemCreated`
- `LearningSessionCompleted`
- `UserProfileUpdated`

### イベントの構造

すべてのイベントが持つべき基本情報：

- **event_id**: イベントの一意識別子
- **aggregate_id**: 集約の識別子
- **stream_id**: イベントストリームの識別子
- **version**: ストリーム内でのバージョン番号
- **schema_version**: イベントスキーマのバージョン
- **occurred_at**: イベント発生時刻（UTC）
- **payload**: イベント固有のデータ

### イベントのサイズ

- 単一イベントは小さく保つ（推奨: 1KB以下）
- 大きなデータは参照として保存
- 必要最小限の情報のみ含める

## Event Store の設計

### ストリーム管理

**ストリームの粒度**:

- 集約ごとに1つのストリーム
- ストリームID = 集約ID
- 関連イベントをグループ化

**バージョニング**:

- 楽観的ロック制御
- 同時実行制御
- 競合検出と解決

### スナップショット

**目的**:

- 読み取りパフォーマンスの向上
- リプレイ時間の短縮
- ストレージ効率の改善

**戦略**:

- N個のイベントごと（例: 100イベント）
- 時間ベース（例: 24時間ごと）
- サイズベース（例: ストリームが1MBを超えたら）

**実装方針**:

- スナップショットは削除可能
- イベントから常に再構築可能
- 非同期で生成

## イベントの発行と購読

### 発行パターン

1. **トランザクショナル発行**:
   - Event Store への保存と同一トランザクション
   - 確実性を重視

2. **非同期発行**:
   - Event Store 保存後に非同期で発行
   - パフォーマンスを重視

### 購読パターン

1. **Catch-up Subscription**:
   - 過去のイベントから読み取り開始
   - 最新に追いつくまで処理

2. **Persistent Subscription**:
   - 購読位置を記憶
   - 再起動後も継続処理

3. **Volatile Subscription**:
   - リアルタイムイベントのみ
   - 過去のイベントは無視

## プロジェクション

### プロジェクションの種類

1. **Read Model プロジェクション**:
   - クエリ用の非正規化ビュー
   - 特定のユースケースに最適化

2. **統計プロジェクション**:
   - 集計データの生成
   - ダッシュボード用データ

3. **通知プロジェクション**:
   - 外部システムへの通知
   - イベント駆動の統合

### プロジェクションの管理

**リビルド戦略**:

- ブルーグリーンデプロイメント
- バージョニングによる並行稼働
- 段階的な切り替え

**エラー処理**:

- 一時的エラーはリトライ
- 永続的エラーはスキップしてログ
- 手動介入の仕組み

## イベントバージョニング戦略

### なぜイベントバージョニングが必要か

Event Sourcing では、イベントは不変の過去の事実です。しかし、ビジネス要件の変化により、イベントのスキーマを進化させる必要があります。この矛盾を解決するのがイベントバージョニングです。

### 実装する3つの戦略

#### 1. Weak Schema（弱いスキーマ）

**概念**:

- 新しいフィールドの追加を許容
- 不明なフィールドは無視
- 最も実用的で柔軟なアプローチ

**実装方法**:

```rust
#[derive(Serialize, Deserialize)]
struct ItemCreated {
    item_id: ItemId,
    name: String,
    #[serde(default)]  // 新フィールドはデフォルト値を持つ
    description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    category: Option<String>,  // v2で追加
}
```

#### 2. Upcasting（アップキャスト）

**概念**:

- 古いイベントを読み込み時に新しい形式に変換
- 変換ロジックを明示的に実装
- イベントストアのデータは変更しない

**実装例**:

```rust
fn upcast_event(event: &RawEvent) -> Result<DomainEvent> {
    match (event.event_type.as_str(), event.schema_version) {
        ("ItemCreated", 1) => {
            // v1 -> v2 への変換
            let v1: ItemCreatedV1 = serde_json::from_value(event.data)?;
            Ok(DomainEvent::ItemCreated(ItemCreated {
                item_id: v1.item_id,
                name: v1.name,
                description: None,  // v2で追加されたフィールド
                category: Some("uncategorized".to_string()),
            }))
        },
        ("ItemCreated", 2) => {
            // 現行バージョンはそのまま
            Ok(serde_json::from_value(event.data)?)
        },
        _ => Err(Error::UnknownEventVersion)
    }
}
```

#### 3. Event Evolution（イベント進化）

**概念**:

- 新しいイベントタイプを導入（例: `ItemCreatedV2`）
- 両方のイベントタイプをサポート
- 段階的な移行が可能

**実装例**:

```rust
enum VocabularyEvent {
    ItemCreated(ItemCreatedV1),      // 廃止予定
    ItemCreatedV2(ItemCreatedV2),    // 新バージョン
    ItemUpdated(ItemUpdated),
    // ...
}

// プロジェクションでは両方を処理
match event {
    VocabularyEvent::ItemCreated(e) => {
        // 旧形式の処理
    },
    VocabularyEvent::ItemCreatedV2(e) => {
        // 新形式の処理
    },
    // ...
}
```

### 実装ガイドライン

1. **スキーマバージョンの記録**
   - すべてのイベントに `schema_version` フィールドを含める
   - イベントタイプごとに独立したバージョン管理

2. **後方互換性の維持**
   - 必須フィールドの削除は避ける
   - フィールドの型変更は新しいフィールドとして追加
   - 意味の変更は新しいイベントタイプを作成

3. **移行戦略**
   - Weak Schema: 即座に適用可能、影響最小
   - Upcasting: 読み取り時のオーバーヘッドあり
   - Event Evolution: 最もクリーンだが実装コスト高

### 学習プロジェクトでの実装例

Vocabulary Context で以下を実装：

1. `ItemCreated` イベントに `schema_version` を追加
2. 新フィールド追加の例（Weak Schema）
3. 1つのイベントで Upcasting の実装例
4. ドキュメントとテストで各戦略の違いを明確化

これにより、Event Sourcing の実践的な課題と解決策を体験的に学習できます。

## パフォーマンス最適化

### イベント読み取り

- バッチ読み取り（例: 100イベントずつ）
- 並列処理可能な場合は並列化
- キャッシュの活用

### イベント書き込み

- バッチ書き込みは避ける（順序性のため）
- 非同期処理の活用
- 適切なインデックス設計

## 運用考慮事項

### アーカイブ戦略

- 古いイベントのアーカイブ
- コールドストレージへの移動
- 必要時の復元手順

### GDPR 対応

- 個人情報を含むイベントの特定
- 暗号化による擬似的な削除
- 忘れられる権利の実装

### 監視項目

- イベントストアのサイズ
- イベント処理の遅延
- プロジェクションの同期状態
- エラー率とリトライ数

## アンチパターン

### ❌ 避けるべきこと

1. **イベントの更新・削除**
2. **巨大なイベント**（メガバイト単位）
3. **同期的な全イベント処理**
4. **イベント内の機密情報**

### ✅ 推奨事項

1. **小さく焦点を絞ったイベント**
2. **非同期処理の活用**
3. **適切なスナップショット戦略**
4. **包括的なエラー処理**

## 実装チェックリスト

- [ ] イベントの命名規則に従っているか
- [ ] イベントは不変として設計されているか
- [ ] 楽観的ロックが実装されているか
- [ ] スナップショット戦略が定義されているか
- [ ] プロジェクションのリビルドが可能か
- [ ] エラー処理が適切に実装されているか
- [ ] 監視とアラートが設定されているか

## 関連ドキュメント

- [共有インフラストラクチャ](shared-infrastructure.md)
- [統合パターン](integration/patterns.md)
- [各コンテキストのイベント定義](contexts/*/events.md)

## 更新履歴

- 2025-08-05: 初版作成
