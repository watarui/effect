# AI Integration Context - アーキテクチャ

## 概要

AI Integration Context は単一サービスアーキテクチャを採用し、外部 AI サービスへの統合ゲートウェイとして機能します。タスクキューベースの非同期処理により、大量の AI 生成要求を効率的に処理します。

## アーキテクチャパターン

### 単一サービス構成

AI Integration Context の特徴：

- **タスクキュー方式**: Redis ベースの非同期タスク処理
- **ワーカープール**: 並列処理による高スループット
- **Anti-Corruption Layer**: 外部 API の変更から内部を保護
- **リアルタイム通知**: WebSocket/SSE による進捗更新

### サービス構成図

```
┌─────────────────────────────────────────────────┐
│         ai-integration-service                  │
│                                                 │
│  ┌──────────────┐    ┌──────────────┐         │
│  │   API Layer  │    │ Worker Pool  │         │
│  │   (gRPC)     │    │              │         │
│  └──────────────┘    └──────────────┘         │
│          │                   │                  │
│          ▼                   ▼                  │
│  ┌──────────────────────────────────┐         │
│  │       Task Queue (Redis)         │         │
│  └──────────────────────────────────┘         │
│          │                                     │
│          ▼                                     │
│  ┌──────────────────────────────────┐         │
│  │   Provider Adapters              │         │
│  │  - Gemini                        │         │
│  │  - OpenAI (GPT-5)                │         │
│  │  - Claude                        │         │
│  │  - Image Services                │         │
│  └──────────────────────────────────┘         │
└─────────────────────────────────────────────────┘
```

## コンポーネント設計

### API Layer

- gRPC エンドポイントの提供
- タスクの受付と ID 返却
- WebSocket/SSE 接続管理

### Task Queue

- Redis による永続化キュー
- 優先度付きキューイング
- デッドレターキュー管理

### Worker Pool

- 設定可能な並列度
- タスクの claim と処理
- 自動リトライとタイムアウト

### Provider Adapters

- 各 AI サービスの抽象化
- Circuit Breaker 実装
- レート制限管理

## データフロー

### タスク処理フロー

1. **タスク受付**: gRPC リクエストを受信
2. **キューイング**: Redis キューに追加
3. **即座の応答**: タスク ID を返却
4. **ワーカー処理**: 空きワーカーがタスクを取得
5. **AI 呼び出し**: 適切なプロバイダーを選択して実行
6. **結果保存**: 生成結果を保存
7. **通知**: WebSocket/SSE で完了通知

## Anti-Corruption Layer

### プロバイダー抽象化

各 AI サービスの差異を吸収：

| プロバイダー | 用途 | 特徴 |
|------------|------|------|
| Gemini | テキスト生成（第一選択） | 高速、コスト効率的 |
| OpenAI GPT-5 | テキスト生成（第二選択） | 最新モデル、高品質 |
| Claude | テキスト生成（第三選択） | 長文コンテキスト |
| Unsplash/Pexels | 画像素材 | 無料、高品質 |

### 統一インターフェース

```
TaskProcessor {
  - processTextGeneration()
  - processImageGeneration()  
  - processChatCompletion()
}
```

## 非同期処理の利点

### スケーラビリティ

- ワーカー数の動的調整
- 負荷に応じた自動スケーリング
- タスクの並列処理

### 耐障害性

- タスクの永続化による障害復旧
- 自動リトライ機構
- Circuit Breaker による保護

### ユーザー体験

- 即座のレスポンス（タスク ID）
- リアルタイム進捗通知
- 長時間処理のサポート

## エラー処理戦略

### リトライポリシー

| エラータイプ | リトライ | バックオフ |
|------------|---------|-----------|
| RateLimit | Yes | 指数バックオフ |
| Timeout | Yes | 線形バックオフ |
| NetworkError | Yes | 指数バックオフ |
| InvalidRequest | No | - |
| InsufficientCredits | No | - |

### Circuit Breaker

- **閾値**: 5回連続失敗
- **オープン期間**: 60秒
- **半開状態**: 1リクエストでテスト
- **リセット**: 成功時に閉状態へ

## パフォーマンス最適化

### キューイング

- バッチ処理による効率化
- 優先度に基づく処理順序
- バックプレッシャー制御

### キャッシング

- 頻繁な要求の結果キャッシュ
- プロンプトテンプレートのキャッシュ

### 接続プーリング

- AI サービスへの接続再利用
- HTTP/2 による多重化

## セキュリティ

### API キー管理

- 環境変数による管理
- Secret Manager 統合
- ローテーション対応

### データ保護

- PII の検出と除去
- リクエスト/レスポンスのサニタイズ
- 監査ログの記録

## 監視とメトリクス

### 重要指標

- タスク処理時間
- キュー長
- ワーカー使用率
- プロバイダー別成功率
- API 使用量とコスト

### アラート

- キュー滞留
- エラー率上昇
- コスト超過警告
- Circuit Breaker 発動
