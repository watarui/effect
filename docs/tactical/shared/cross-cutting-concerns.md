# 横断的関心事（Cross-Cutting Concerns）

## 概要

横断的関心事は、複数の境界づけられたコンテキストにまたがる共通の技術的課題です。これらを適切に管理することで、一貫性のあるシステムを構築できます。

## エラー処理

### エラー分類

#### ドメインエラー

ビジネスルール違反や業務上の例外：

- **ValidationError**: 入力検証エラー
- **BusinessRuleViolation**: ビジネスルール違反
- **ConflictError**: リソース競合
- **NotFoundError**: リソース不在

#### インフラストラクチャエラー

技術的な問題に起因するエラー：

- **DatabaseError**: データベース接続・クエリエラー
- **NetworkError**: ネットワーク通信エラー
- **TimeoutError**: タイムアウト
- **ExternalServiceError**: 外部サービスエラー

### エラー処理方針

1. **エラーの伝播**
   - 下位層から上位層へ適切に変換
   - コンテキストを保持しながら抽象化
   - スタックトレースの保存

2. **エラーレスポンス**
   - 構造化されたエラー形式
   - エラーコードによる分類
   - ユーザー向けメッセージの分離

3. **リトライ戦略**
   - 一時的エラーの自動リトライ
   - 指数バックオフ
   - サーキットブレーカー

実装: `shared/cross_cutting/error/`

## セキュリティ

### 認証・認可

**認証方式**:

- Firebase Authentication によるトークンベース認証
- JWT トークンの検証
- セッション管理なし（ステートレス）

**認可モデル**:

- ロールベースアクセス制御（RBAC）
- リソースレベルの権限チェック
- コンテキスト境界での認可

### データ保護

1. **通信の暗号化**
   - HTTPS/TLS による通信
   - gRPC の TLS 設定
   - 証明書管理

2. **データの暗号化**
   - 機密データの暗号化保存
   - 暗号化キーの管理
   - GDPR 準拠

3. **シークレット管理**
   - 環境変数による設定
   - Cloud Secret Manager の使用
   - ローテーション戦略

実装: `shared/cross_cutting/security/`

## 観測性（Observability）

### ロギング

**ログレベル**:

- ERROR: エラーと例外
- WARN: 警告と潜在的問題
- INFO: 重要なビジネスイベント
- DEBUG: デバッグ情報
- TRACE: 詳細なトレース情報

**構造化ログ**:

- JSON 形式での出力
- コンテキスト情報の付与
- 相関IDによる追跡

**ログ出力先**:

- 開発環境: コンソール
- 本番環境: Cloud Logging

### メトリクス

**収集項目**:

- リクエスト数とレスポンスタイム
- エラー率
- リソース使用率
- ビジネスメトリクス

**実装方針**:

- 学習用プロジェクトとして、シンプルな実装を優先
- 基本的なメトリクスは構造化ログで代替
- 本番環境では Cloud Monitoring の基本機能を活用
- OpenTelemetry/Prometheus は将来の拡張オプションとして記載

### 分散トレーシング

**トレース戦略**:

- リクエスト全体の追跡
- サービス間の呼び出し関係
- パフォーマンスボトルネックの特定

**実装**:

- OpenTelemetry による実装
- Cloud Trace との統合
- サンプリング戦略

実装: `shared/cross_cutting/telemetry/`

## キャッシング

### キャッシュ戦略

1. **Read-Through キャッシュ**
   - 自動的なキャッシュ更新
   - TTL による有効期限管理

2. **Write-Through キャッシュ**
   - 書き込み時の同時更新
   - 一貫性の保証

3. **Cache-Aside パターン**
   - アプリケーション制御
   - 柔軟な無効化戦略

### キャッシュレイヤー

1. **アプリケーションキャッシュ**
   - インメモリキャッシュ
   - 短期間の高速アクセス

2. **分散キャッシュ**
   - Redis による共有キャッシュ
   - セッション情報の保存

3. **CDN キャッシュ**
   - 静的コンテンツの配信
   - エッジロケーション活用

実装: `shared/cross_cutting/cache/`

## 設定管理

### 設定の階層

1. **デフォルト設定**
   - コード内のデフォルト値
   - 開発環境の標準設定

2. **環境別設定**
   - 環境変数による上書き
   - 設定ファイルの分離

3. **動的設定**
   - 実行時の設定変更
   - フィーチャーフラグ

### 設定の管理

**原則**:

- 機密情報はコードに含めない
- 環境依存の分離
- 型安全な設定アクセス

**実装方法**:

- 環境変数の使用
- 設定ファイルの階層化
- バリデーション機能

実装: `shared/cross_cutting/config/`

## レート制限

### 制限戦略

1. **ユーザーベース**
   - 認証ユーザー: 600 req/min
   - 未認証ユーザー: 60 req/min

2. **エンドポイントベース**
   - 重い処理: より厳しい制限
   - 軽い処理: 緩い制限

3. **適応的制限**
   - システム負荷に応じた調整
   - 優先度に基づく制御

### 実装方法

- トークンバケットアルゴリズム
- Redis によるカウンター管理
- 429 Too Many Requests の返却

## ヘルスチェック

### チェック項目

1. **Liveness**
   - プロセスの生存確認
   - デッドロック検出
   - `/health/live` エンドポイント

2. **Readiness**
   - サービス提供可能状態
   - 依存サービスの確認
   - `/health/ready` エンドポイント

3. **依存関係チェック**
   - データベース接続
   - 外部サービス到達性
   - キャッシュ接続

## バージョニング

### 学習プロジェクトとしての方針

**API バージョニング**:

- Event Sourcing との相互作用を学ぶため、最初から実装
- URL パス方式（`/api/v1/`）でシンプルに実装
- バージョンごとに異なる Read Model を提供可能
- GraphQL では `@deprecated` ディレクティブも活用

**イベントバージョニング**:

- Event Sourcing の重要な学習要素として実践的に実装
- スキーマ進化の3つの戦略を体験
- 詳細は [Event Sourcing ガイドライン](../event-sourcing-guidelines.md#イベントバージョニング戦略) を参照

**Read Model バージョニング**:

- API バージョンごとに独立した Read Model
- 同一のイベントストリームから複数のビューを生成
- クライアントの段階的移行をサポート

**データバージョニング**:

- スキーママイグレーションは SQLx で管理
- 破壊的変更時は再構築も許容（学習環境のため）

## 実装ガイドライン

### Do's ✅

1. **一貫性のある実装**
   - 共通ライブラリの使用
   - 標準化されたパターン

2. **適切な抽象化**
   - 過度な汎用化を避ける
   - 明確なインターフェース

3. **テスタビリティ**
   - モック可能な設計
   - 単体テストの容易性

### Don'ts ❌

1. **過度な共通化**
   - コンテキスト固有のロジックを含めない
   - 無理な統一を避ける

2. **密結合**
   - 直接的な依存を避ける
   - インターフェースによる分離

## 関連ドキュメント

- [共有インフラストラクチャ](infrastructure.md)
- [Shared Kernel](kernel.md)
- [技術的負債](../technical-debt.md)

## 更新履歴

- 2025-08-05: 初版作成
